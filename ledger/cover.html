
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ledger/cmd/main.go (0.0%)</option>
				
				<option value="file1">ledger/internal/cache/cache.go (0.0%)</option>
				
				<option value="file2">ledger/internal/db/db.go (0.0%)</option>
				
				<option value="file3">ledger/internal/domain/budget.go (0.0%)</option>
				
				<option value="file4">ledger/internal/domain/transaction.go (0.0%)</option>
				
				<option value="file5">ledger/internal/grpcserver/ledger_server.go (79.7%)</option>
				
				<option value="file6">ledger/internal/pb/ledger/v1/ledger.pb.go (0.0%)</option>
				
				<option value="file7">ledger/internal/pb/ledger/v1/ledger_grpc.pb.go (0.0%)</option>
				
				<option value="file8">ledger/internal/repository/pg/budget.go (91.9%)</option>
				
				<option value="file9">ledger/internal/repository/pg/summary.go (72.9%)</option>
				
				<option value="file10">ledger/internal/repository/pg/transaction.go (86.7%)</option>
				
				<option value="file11">ledger/internal/service/service.go (41.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "ledger/internal/cache"
        "ledger/internal/db"
        "ledger/internal/grpcserver"
        "ledger/internal/repository/pg"
        "ledger/internal/service"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"

        pb "ledger/internal/pb/ledger/v1"

        "golang.org/x/sync/errgroup"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        println("Start app")
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        grpcPort := os.Getenv("GRPC_PORT")
        if grpcPort == "" </span><span class="cov0" title="0">{
                grpcPort = "9090"
        }</span>
        <span class="cov0" title="0">grpcAddr := ":" + grpcPort
        lis, err := net.Listen("tcp", grpcAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("listen gRPC: %v", err)
        }</span>

        <span class="cov0" title="0">grpcSrv := grpc.NewServer()

        healthSrv := health.NewServer()
        grpc_health_v1.RegisterHealthServer(grpcSrv, healthSrv)

        println("Try connect to db")
        dbConn, err := db.Connect()
        if err != nil </span><span class="cov0" title="0">{
                println("Db connect error: %v", err.Error())
                healthSrv.SetServingStatus("", grpc_health_v1.HealthCheckResponse_NOT_SERVING)
                return
        }</span>
        <span class="cov0" title="0">defer dbConn.Close()
        println("Db connected")

        redisConn, err := cache.Connect()
        if err != nil </span><span class="cov0" title="0">{
                println("Redis conntect error: %v", err.Error())
                healthSrv.SetServingStatus("", grpc_health_v1.HealthCheckResponse_NOT_SERVING)
                return
        }</span>
        <span class="cov0" title="0">defer redisConn.Close()

        ledgerService := service.NewLedgerService(
                pg.NewBudgetPgRepository(dbConn, redisConn),
                pg.NewTransactionPgRepository(dbConn),
                pg.NewSummaryPgRepository(dbConn, redisConn),
        )
        pb.RegisterLedgerServiceServer(grpcSrv, grpcserver.NewLedgerServer(ledgerService))

        reflection.Register(grpcSrv)

        healthSrv.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)

        g, gctx := errgroup.WithContext(ctx)

        g.Go(func() error </span><span class="cov0" title="0">{
                log.Printf("gRPC server listening on %s", grpcAddr)
                if err := grpcSrv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{
                &lt;-gctx.Done()
                grpcSrv.GracefulStop()
                return nil
        }</span>)

        <span class="cov0" title="0">if err := g.Wait(); err != nil &amp;&amp; !errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                log.Fatalf("server error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "context"
        "os"
        "strconv"

        "github.com/redis/go-redis/v9"
)

func Connect() (*redis.Client, error) <span class="cov0" title="0">{
        db, err := strconv.Atoi(os.Getenv("REDIS_DB"))
        if err != nil </span><span class="cov0" title="0">{
                db = 0
        }</span>
        <span class="cov0" title="0">client := redis.NewClient(&amp;redis.Options{
                Addr:     os.Getenv("REDIS_ADDR"),
                Password: os.Getenv("REDIS_PASSWORD"),
                DB:       db,
        })
        context := context.Background()
        _, err = client.Ping(context).Result()
        if err != nil </span><span class="cov0" title="0">{
                println(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">println("Connected to redis")
        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        "database/sql"
        "os"

        _ "github.com/lib/pq"
)

func Connect() (*sql.DB, error) <span class="cov0" title="0">{
        dsn := os.Getenv("DATABASE_URL")
        db, err := sql.Open("postgres", dsn)
        db.SetMaxIdleConns(5)
        db.SetMaxOpenConns(10)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">println("Connected to database")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "context"
        "errors"
)

type Budget struct {
        Category string  `json:"category"`
        Limit    float64 `json:"limit"`
}

func (budget *Budget) Validate() error <span class="cov0" title="0">{
        if budget.Limit &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("invalid limit")
        }</span>
        <span class="cov0" title="0">if budget.Category == "" </span><span class="cov0" title="0">{
                return errors.New("invalid category")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BudgetRepository interface {
        SetBudget(budget *Budget, ctx context.Context) error
        GetBudgets(ctx context.Context) ([]Budget, error)
        GetBudget(category string, ctx context.Context) (*Budget, error)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package domain

import (
        "context"
        "errors"
)

type Transaction struct {
        ID          int64
        Amount      float64
        Category    string
        Description string
        Date        string
}

func (tx *Transaction) Validate() error <span class="cov0" title="0">{
        if tx.Amount &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("invalid amount")
        }</span>
        <span class="cov0" title="0">if tx.Category == "" </span><span class="cov0" title="0">{
                return errors.New("invalid category")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TransactionRepository interface {
        AddTransaction(transaction *Transaction, ctx context.Context) (int64, error)
        GetTransaction(id int64, ctx context.Context) (*Transaction, error)
        ListTransactions(ctx context.Context) ([]Transaction, error)
        GetAmountTransactionByCategory(category string, ctx context.Context) (float64, error)
        GetAmountTransactionByCategoryAndMonth(ctx context.Context, category string, date string) (float64, error)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package grpcserver

import (
        "context"
        "ledger/internal/domain"
        pb "ledger/internal/pb/ledger/v1"
        "ledger/internal/service"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
)

type LedgerServer struct {
        pb.UnimplementedLedgerServiceServer
        ledgerService service.LedgerService
}

var _ pb.LedgerServiceServer = (*LedgerServer)(nil)

func NewLedgerServer(svc service.LedgerService) *LedgerServer <span class="cov8" title="1">{
        return &amp;LedgerServer{ledgerService: svc}
}</span>

func (s *LedgerServer) BudgetAdd(ctx context.Context, req *pb.BudgetAddRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        if req.GetCategory() == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "category is required")
        }</span>
        <span class="cov8" title="1">if req.GetLimit() == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "limit is required")
        }</span>
        <span class="cov8" title="1">budget := domain.Budget{
                Category: req.GetCategory(),
                Limit:    float64(req.GetLimit()),
        }
        err := s.ledgerService.BudgetAdd(ctx, &amp;budget)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "set budget: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *LedgerServer) BudgetGet(ctx context.Context, req *pb.BudgetGetRequest) (*pb.BudgetGetResponse, error) <span class="cov8" title="1">{
        if req.GetCategory() == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "category is required")
        }</span>
        <span class="cov8" title="1">resp, err := s.ledgerService.BudgetGet(ctx, req.GetCategory())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "get budget: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;pb.BudgetGetResponse{
                Category: resp.Category,
                Limit:    float32(resp.Limit),
        }, nil</span>
}

func (s *LedgerServer) BudgetsList(ctx context.Context, _ *emptypb.Empty) (*pb.BudgetGetListResponse, error) <span class="cov8" title="1">{
        budgets, err := s.ledgerService.BudgetsList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "get budgets: %v", err)
        }</span>

        <span class="cov8" title="1">pbBudgets := make([]*pb.BudgetGetResponse, 0)
        for _, budget := range budgets </span><span class="cov8" title="1">{
                pbBudgets = append(pbBudgets, &amp;pb.BudgetGetResponse{
                        Category: budget.Category,
                        Limit:    float32(budget.Limit),
                })
        }</span>

        <span class="cov8" title="1">return &amp;pb.BudgetGetListResponse{
                Budgets: pbBudgets,
        }, nil</span>
}

func (s *LedgerServer) TransactionAdd(ctx context.Context, req *pb.TransactionAddRequest) (*pb.TransactionAddResponse, error) <span class="cov8" title="1">{
        if req.GetAmount() == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "amount is required")
        }</span>
        <span class="cov8" title="1">if req.GetCategory() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "category is required")
        }</span>
        <span class="cov8" title="1">if req.GetDate() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "date is required")
        }</span>
        <span class="cov8" title="1">if req.GetDescription() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "description is required")
        }</span>
        <span class="cov8" title="1">tr := domain.Transaction{
                Amount:      float64(req.GetAmount()),
                Category:    req.GetCategory(),
                Date:        req.GetDate(),
                Description: req.GetDescription(),
        }
        id, err := s.ledgerService.TransactionAdd(ctx, &amp;tr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "add transaction: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;pb.TransactionAddResponse{
                Id: id,
        }, nil</span>
}

func (s *LedgerServer) TransactionGet(ctx context.Context, req *pb.TransactionGetRequest) (*pb.TransactionGetResponse, error) <span class="cov8" title="1">{
        if req.GetId() == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "id is required")
        }</span>
        <span class="cov8" title="1">tr, err := s.ledgerService.TransactionGet(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "get transaction: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;pb.TransactionGetResponse{
                Id:          tr.ID,
                Amount:      float32(tr.Amount),
                Category:    tr.Category,
                Date:        tr.Date,
                Description: tr.Description,
        }, nil</span>
}

func (s *LedgerServer) TransactionList(ctx context.Context, req *emptypb.Empty) (*pb.TransactionGetListResponse, error) <span class="cov8" title="1">{
        trs, err := s.ledgerService.TransactionsList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "list transactions: %v", err)
        }</span>
        <span class="cov8" title="1">pbTrs := make([]*pb.TransactionGetResponse, len(trs))
        for i, tr := range trs </span><span class="cov8" title="1">{
                pbTrs[i] = &amp;pb.TransactionGetResponse{
                        Id:          tr.ID,
                        Amount:      float32(tr.Amount),
                        Category:    tr.Category,
                        Date:        tr.Date,
                        Description: tr.Description,
                }
        }</span>

        <span class="cov8" title="1">return &amp;pb.TransactionGetListResponse{
                Transactions: pbTrs,
        }, nil</span>
}

func (s *LedgerServer) ReportSummary(ctx context.Context, req *pb.SummaryRequest) (*pb.SummaryResponse, error) <span class="cov8" title="1">{
        if req.From == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "from is required")
        }</span>
        <span class="cov8" title="1">if req.To == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "to is required")
        }</span>
        <span class="cov8" title="1">summary, err := s.ledgerService.GetReportSummary(ctx, req.From, req.To)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "report summary: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;pb.SummaryResponse{
                Report:      summary.Categories,
                CacheResult: summary.CacheResult,
        }, nil</span>
}

func (s *LedgerServer) BulkAddTransactions(ctx context.Context, req *pb.TransactionBulkAddRequest) (*pb.TransactionBulkAddResponse, error) <span class="cov8" title="1">{
        trs := make([]domain.Transaction, 0, len(req.Transactions))
        for _, transaction := range req.Transactions </span><span class="cov8" title="1">{
                trs = append(trs, domain.Transaction{
                        Amount:      float64(transaction.Amount),
                        Category:    transaction.Category,
                        Description: transaction.Description,
                        Date:        transaction.Date,
                })
        }</span>
        <span class="cov8" title="1">resp, err := s.ledgerService.BulkAddTransactions(ctx, trs, 4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "bulk add transaction: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;pb.TransactionBulkAddResponse{
                Accepted: resp.Accepted,
                Rejected: resp.Rejected,
                Errors:   resp.Errors,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.11
//         protoc        v6.33.2
// source: ledger/v1/ledger.proto

package v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BudgetAddRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Category      string                 `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
        Limit         float32                `protobuf:"fixed32,2,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BudgetAddRequest) Reset() <span class="cov0" title="0">{
        *x = BudgetAddRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BudgetAddRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BudgetAddRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BudgetAddRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BudgetAddRequest.ProtoReflect.Descriptor instead.
func (*BudgetAddRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{0}
}</span>

func (x *BudgetAddRequest) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BudgetAddRequest) GetLimit() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type BudgetGetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Category      string                 `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BudgetGetRequest) Reset() <span class="cov0" title="0">{
        *x = BudgetGetRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BudgetGetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BudgetGetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BudgetGetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BudgetGetRequest.ProtoReflect.Descriptor instead.
func (*BudgetGetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{1}
}</span>

func (x *BudgetGetRequest) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BudgetGetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Category      string                 `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
        Limit         float32                `protobuf:"fixed32,2,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BudgetGetResponse) Reset() <span class="cov0" title="0">{
        *x = BudgetGetResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BudgetGetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BudgetGetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BudgetGetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BudgetGetResponse.ProtoReflect.Descriptor instead.
func (*BudgetGetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{2}
}</span>

func (x *BudgetGetResponse) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BudgetGetResponse) GetLimit() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type BudgetGetListResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Budgets       []*BudgetGetResponse   `protobuf:"bytes,1,rep,name=budgets,proto3" json:"budgets,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BudgetGetListResponse) Reset() <span class="cov0" title="0">{
        *x = BudgetGetListResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BudgetGetListResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BudgetGetListResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BudgetGetListResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BudgetGetListResponse.ProtoReflect.Descriptor instead.
func (*BudgetGetListResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{3}
}</span>

func (x *BudgetGetListResponse) GetBudgets() []*BudgetGetResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Budgets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TransactionAddRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Amount        float32                `protobuf:"fixed32,1,opt,name=amount,proto3" json:"amount,omitempty"`
        Category      string                 `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty"`
        Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Date          string                 `protobuf:"bytes,4,opt,name=date,proto3" json:"date,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionAddRequest) Reset() <span class="cov0" title="0">{
        *x = TransactionAddRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionAddRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionAddRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionAddRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionAddRequest.ProtoReflect.Descriptor instead.
func (*TransactionAddRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{4}
}</span>

func (x *TransactionAddRequest) GetAmount() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TransactionAddRequest) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransactionAddRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransactionAddRequest) GetDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Date
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TransactionBulkAddRequest struct {
        state         protoimpl.MessageState   `protogen:"open.v1"`
        Transactions  []*TransactionAddRequest `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionBulkAddRequest) Reset() <span class="cov0" title="0">{
        *x = TransactionBulkAddRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionBulkAddRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionBulkAddRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionBulkAddRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionBulkAddRequest.ProtoReflect.Descriptor instead.
func (*TransactionBulkAddRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{5}
}</span>

func (x *TransactionBulkAddRequest) GetTransactions() []*TransactionAddRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transactions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TransactionBulkAddResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Accepted      int64                  `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
        Rejected      int64                  `protobuf:"varint,2,opt,name=rejected,proto3" json:"rejected,omitempty"`
        Errors        map[int64]string       `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionBulkAddResponse) Reset() <span class="cov0" title="0">{
        *x = TransactionBulkAddResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionBulkAddResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionBulkAddResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionBulkAddResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionBulkAddResponse.ProtoReflect.Descriptor instead.
func (*TransactionBulkAddResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{6}
}</span>

func (x *TransactionBulkAddResponse) GetAccepted() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Accepted
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TransactionBulkAddResponse) GetRejected() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rejected
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TransactionBulkAddResponse) GetErrors() map[int64]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TransactionAddResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionAddResponse) Reset() <span class="cov0" title="0">{
        *x = TransactionAddResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionAddResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionAddResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionAddResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionAddResponse.ProtoReflect.Descriptor instead.
func (*TransactionAddResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{7}
}</span>

func (x *TransactionAddResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TransactionGetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionGetRequest) Reset() <span class="cov0" title="0">{
        *x = TransactionGetRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionGetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionGetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionGetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionGetRequest.ProtoReflect.Descriptor instead.
func (*TransactionGetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{8}
}</span>

func (x *TransactionGetRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TransactionGetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Amount        float32                `protobuf:"fixed32,2,opt,name=amount,proto3" json:"amount,omitempty"`
        Category      string                 `protobuf:"bytes,3,opt,name=category,proto3" json:"category,omitempty"`
        Description   string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
        Date          string                 `protobuf:"bytes,5,opt,name=date,proto3" json:"date,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionGetResponse) Reset() <span class="cov0" title="0">{
        *x = TransactionGetResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionGetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionGetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionGetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionGetResponse.ProtoReflect.Descriptor instead.
func (*TransactionGetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{9}
}</span>

func (x *TransactionGetResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TransactionGetResponse) GetAmount() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TransactionGetResponse) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransactionGetResponse) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransactionGetResponse) GetDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Date
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TransactionGetListResponse struct {
        state         protoimpl.MessageState    `protogen:"open.v1"`
        Transactions  []*TransactionGetResponse `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TransactionGetListResponse) Reset() <span class="cov0" title="0">{
        *x = TransactionGetListResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TransactionGetListResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransactionGetListResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransactionGetListResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransactionGetListResponse.ProtoReflect.Descriptor instead.
func (*TransactionGetListResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{10}
}</span>

func (x *TransactionGetListResponse) GetTransactions() []*TransactionGetResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transactions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SummaryRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        From          string                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
        To            string                 `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SummaryRequest) Reset() <span class="cov0" title="0">{
        *x = SummaryRequest{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SummaryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SummaryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SummaryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SummaryRequest.ProtoReflect.Descriptor instead.
func (*SummaryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{11}
}</span>

func (x *SummaryRequest) GetFrom() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.From
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SummaryRequest) GetTo() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.To
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SummaryResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Report        map[string]float64     `protobuf:"bytes,1,rep,name=report,proto3" json:"report,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        CacheResult   bool                   `protobuf:"varint,2,opt,name=cache_result,json=cacheResult,proto3" json:"cache_result,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SummaryResponse) Reset() <span class="cov0" title="0">{
        *x = SummaryResponse{}
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SummaryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SummaryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SummaryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_v1_ledger_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SummaryResponse.ProtoReflect.Descriptor instead.
func (*SummaryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_v1_ledger_proto_rawDescGZIP(), []int{12}
}</span>

func (x *SummaryResponse) GetReport() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Report
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SummaryResponse) GetCacheResult() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CacheResult
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_ledger_v1_ledger_proto protoreflect.FileDescriptor

const file_ledger_v1_ledger_proto_rawDesc = "" +
        "\n" +
        "\x16ledger/v1/ledger.proto\x12\tledger.v1\x1a\x1bgoogle/protobuf/empty.proto\"D\n" +
        "\x10BudgetAddRequest\x12\x1a\n" +
        "\bcategory\x18\x01 \x01(\tR\bcategory\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x02R\x05limit\".\n" +
        "\x10BudgetGetRequest\x12\x1a\n" +
        "\bcategory\x18\x01 \x01(\tR\bcategory\"E\n" +
        "\x11BudgetGetResponse\x12\x1a\n" +
        "\bcategory\x18\x01 \x01(\tR\bcategory\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x02R\x05limit\"O\n" +
        "\x15BudgetGetListResponse\x126\n" +
        "\abudgets\x18\x01 \x03(\v2\x1c.ledger.v1.BudgetGetResponseR\abudgets\"\x81\x01\n" +
        "\x15TransactionAddRequest\x12\x16\n" +
        "\x06amount\x18\x01 \x01(\x02R\x06amount\x12\x1a\n" +
        "\bcategory\x18\x02 \x01(\tR\bcategory\x12 \n" +
        "\vdescription\x18\x03 \x01(\tR\vdescription\x12\x12\n" +
        "\x04date\x18\x04 \x01(\tR\x04date\"a\n" +
        "\x19TransactionBulkAddRequest\x12D\n" +
        "\ftransactions\x18\x01 \x03(\v2 .ledger.v1.TransactionAddRequestR\ftransactions\"\xda\x01\n" +
        "\x1aTransactionBulkAddResponse\x12\x1a\n" +
        "\baccepted\x18\x01 \x01(\x03R\baccepted\x12\x1a\n" +
        "\brejected\x18\x02 \x01(\x03R\brejected\x12I\n" +
        "\x06errors\x18\x03 \x03(\v21.ledger.v1.TransactionBulkAddResponse.ErrorsEntryR\x06errors\x1a9\n" +
        "\vErrorsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"(\n" +
        "\x16TransactionAddResponse\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\"'\n" +
        "\x15TransactionGetRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\"\x92\x01\n" +
        "\x16TransactionGetResponse\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\x12\x16\n" +
        "\x06amount\x18\x02 \x01(\x02R\x06amount\x12\x1a\n" +
        "\bcategory\x18\x03 \x01(\tR\bcategory\x12 \n" +
        "\vdescription\x18\x04 \x01(\tR\vdescription\x12\x12\n" +
        "\x04date\x18\x05 \x01(\tR\x04date\"c\n" +
        "\x1aTransactionGetListResponse\x12E\n" +
        "\ftransactions\x18\x01 \x03(\v2!.ledger.v1.TransactionGetResponseR\ftransactions\"4\n" +
        "\x0eSummaryRequest\x12\x12\n" +
        "\x04from\x18\x01 \x01(\tR\x04from\x12\x0e\n" +
        "\x02to\x18\x02 \x01(\tR\x02to\"\xaf\x01\n" +
        "\x0fSummaryResponse\x12&gt;\n" +
        "\x06report\x18\x01 \x03(\v2&amp;.ledger.v1.SummaryResponse.ReportEntryR\x06report\x12!\n" +
        "\fcache_result\x18\x02 \x01(\bR\vcacheResult\x1a9\n" +
        "\vReportEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x012\x8e\x05\n" +
        "\rLedgerService\x12@\n" +
        "\tBudgetAdd\x12\x1b.ledger.v1.BudgetAddRequest\x1a\x16.google.protobuf.Empty\x12F\n" +
        "\tBudgetGet\x12\x1b.ledger.v1.BudgetGetRequest\x1a\x1c.ledger.v1.BudgetGetResponse\x12G\n" +
        "\vBudgetsList\x12\x16.google.protobuf.Empty\x1a .ledger.v1.BudgetGetListResponse\x12U\n" +
        "\x0eTransactionAdd\x12 .ledger.v1.TransactionAddRequest\x1a!.ledger.v1.TransactionAddResponse\x12U\n" +
        "\x0eTransactionGet\x12 .ledger.v1.TransactionGetRequest\x1a!.ledger.v1.TransactionGetResponse\x12P\n" +
        "\x0fTransactionList\x12\x16.google.protobuf.Empty\x1a%.ledger.v1.TransactionGetListResponse\x12F\n" +
        "\rReportSummary\x12\x19.ledger.v1.SummaryRequest\x1a\x1a.ledger.v1.SummaryResponse\x12b\n" +
        "\x13BulkAddTransactions\x12$.ledger.v1.TransactionBulkAddRequest\x1a%.ledger.v1.TransactionBulkAddResponseB\x1eZ\x1cledger/internal/pb/ledger/v1b\x06proto3"

var (
        file_ledger_v1_ledger_proto_rawDescOnce sync.Once
        file_ledger_v1_ledger_proto_rawDescData []byte
)

func file_ledger_v1_ledger_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_ledger_v1_ledger_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_ledger_v1_ledger_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ledger_v1_ledger_proto_rawDesc), len(file_ledger_v1_ledger_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_ledger_v1_ledger_proto_rawDescData</span>
}

var file_ledger_v1_ledger_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_ledger_v1_ledger_proto_goTypes = []any{
        (*BudgetAddRequest)(nil),           // 0: ledger.v1.BudgetAddRequest
        (*BudgetGetRequest)(nil),           // 1: ledger.v1.BudgetGetRequest
        (*BudgetGetResponse)(nil),          // 2: ledger.v1.BudgetGetResponse
        (*BudgetGetListResponse)(nil),      // 3: ledger.v1.BudgetGetListResponse
        (*TransactionAddRequest)(nil),      // 4: ledger.v1.TransactionAddRequest
        (*TransactionBulkAddRequest)(nil),  // 5: ledger.v1.TransactionBulkAddRequest
        (*TransactionBulkAddResponse)(nil), // 6: ledger.v1.TransactionBulkAddResponse
        (*TransactionAddResponse)(nil),     // 7: ledger.v1.TransactionAddResponse
        (*TransactionGetRequest)(nil),      // 8: ledger.v1.TransactionGetRequest
        (*TransactionGetResponse)(nil),     // 9: ledger.v1.TransactionGetResponse
        (*TransactionGetListResponse)(nil), // 10: ledger.v1.TransactionGetListResponse
        (*SummaryRequest)(nil),             // 11: ledger.v1.SummaryRequest
        (*SummaryResponse)(nil),            // 12: ledger.v1.SummaryResponse
        nil,                                // 13: ledger.v1.TransactionBulkAddResponse.ErrorsEntry
        nil,                                // 14: ledger.v1.SummaryResponse.ReportEntry
        (*emptypb.Empty)(nil),              // 15: google.protobuf.Empty
}
var file_ledger_v1_ledger_proto_depIdxs = []int32{
        2,  // 0: ledger.v1.BudgetGetListResponse.budgets:type_name -&gt; ledger.v1.BudgetGetResponse
        4,  // 1: ledger.v1.TransactionBulkAddRequest.transactions:type_name -&gt; ledger.v1.TransactionAddRequest
        13, // 2: ledger.v1.TransactionBulkAddResponse.errors:type_name -&gt; ledger.v1.TransactionBulkAddResponse.ErrorsEntry
        9,  // 3: ledger.v1.TransactionGetListResponse.transactions:type_name -&gt; ledger.v1.TransactionGetResponse
        14, // 4: ledger.v1.SummaryResponse.report:type_name -&gt; ledger.v1.SummaryResponse.ReportEntry
        0,  // 5: ledger.v1.LedgerService.BudgetAdd:input_type -&gt; ledger.v1.BudgetAddRequest
        1,  // 6: ledger.v1.LedgerService.BudgetGet:input_type -&gt; ledger.v1.BudgetGetRequest
        15, // 7: ledger.v1.LedgerService.BudgetsList:input_type -&gt; google.protobuf.Empty
        4,  // 8: ledger.v1.LedgerService.TransactionAdd:input_type -&gt; ledger.v1.TransactionAddRequest
        8,  // 9: ledger.v1.LedgerService.TransactionGet:input_type -&gt; ledger.v1.TransactionGetRequest
        15, // 10: ledger.v1.LedgerService.TransactionList:input_type -&gt; google.protobuf.Empty
        11, // 11: ledger.v1.LedgerService.ReportSummary:input_type -&gt; ledger.v1.SummaryRequest
        5,  // 12: ledger.v1.LedgerService.BulkAddTransactions:input_type -&gt; ledger.v1.TransactionBulkAddRequest
        15, // 13: ledger.v1.LedgerService.BudgetAdd:output_type -&gt; google.protobuf.Empty
        2,  // 14: ledger.v1.LedgerService.BudgetGet:output_type -&gt; ledger.v1.BudgetGetResponse
        3,  // 15: ledger.v1.LedgerService.BudgetsList:output_type -&gt; ledger.v1.BudgetGetListResponse
        7,  // 16: ledger.v1.LedgerService.TransactionAdd:output_type -&gt; ledger.v1.TransactionAddResponse
        9,  // 17: ledger.v1.LedgerService.TransactionGet:output_type -&gt; ledger.v1.TransactionGetResponse
        10, // 18: ledger.v1.LedgerService.TransactionList:output_type -&gt; ledger.v1.TransactionGetListResponse
        12, // 19: ledger.v1.LedgerService.ReportSummary:output_type -&gt; ledger.v1.SummaryResponse
        6,  // 20: ledger.v1.LedgerService.BulkAddTransactions:output_type -&gt; ledger.v1.TransactionBulkAddResponse
        13, // [13:21] is the sub-list for method output_type
        5,  // [5:13] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_ledger_v1_ledger_proto_init() }</span>
func file_ledger_v1_ledger_proto_init() <span class="cov0" title="0">{
        if File_ledger_v1_ledger_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_ledger_v1_ledger_proto_rawDesc), len(file_ledger_v1_ledger_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   15,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_ledger_v1_ledger_proto_goTypes,
                DependencyIndexes: file_ledger_v1_ledger_proto_depIdxs,
                MessageInfos:      file_ledger_v1_ledger_proto_msgTypes,
        }.Build()
        File_ledger_v1_ledger_proto = out.File
        file_ledger_v1_ledger_proto_goTypes = nil
        file_ledger_v1_ledger_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: ledger/v1/ledger.proto

package v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        LedgerService_BudgetAdd_FullMethodName           = "/ledger.v1.LedgerService/BudgetAdd"
        LedgerService_BudgetGet_FullMethodName           = "/ledger.v1.LedgerService/BudgetGet"
        LedgerService_BudgetsList_FullMethodName         = "/ledger.v1.LedgerService/BudgetsList"
        LedgerService_TransactionAdd_FullMethodName      = "/ledger.v1.LedgerService/TransactionAdd"
        LedgerService_TransactionGet_FullMethodName      = "/ledger.v1.LedgerService/TransactionGet"
        LedgerService_TransactionList_FullMethodName     = "/ledger.v1.LedgerService/TransactionList"
        LedgerService_ReportSummary_FullMethodName       = "/ledger.v1.LedgerService/ReportSummary"
        LedgerService_BulkAddTransactions_FullMethodName = "/ledger.v1.LedgerService/BulkAddTransactions"
)

// LedgerServiceClient is the client API for LedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LedgerServiceClient interface {
        BudgetAdd(ctx context.Context, in *BudgetAddRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        BudgetGet(ctx context.Context, in *BudgetGetRequest, opts ...grpc.CallOption) (*BudgetGetResponse, error)
        BudgetsList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BudgetGetListResponse, error)
        TransactionAdd(ctx context.Context, in *TransactionAddRequest, opts ...grpc.CallOption) (*TransactionAddResponse, error)
        TransactionGet(ctx context.Context, in *TransactionGetRequest, opts ...grpc.CallOption) (*TransactionGetResponse, error)
        TransactionList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionGetListResponse, error)
        ReportSummary(ctx context.Context, in *SummaryRequest, opts ...grpc.CallOption) (*SummaryResponse, error)
        BulkAddTransactions(ctx context.Context, in *TransactionBulkAddRequest, opts ...grpc.CallOption) (*TransactionBulkAddResponse, error)
}

type ledgerServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewLedgerServiceClient(cc grpc.ClientConnInterface) LedgerServiceClient <span class="cov0" title="0">{
        return &amp;ledgerServiceClient{cc}
}</span>

func (c *ledgerServiceClient) BudgetAdd(ctx context.Context, in *BudgetAddRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, LedgerService_BudgetAdd_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) BudgetGet(ctx context.Context, in *BudgetGetRequest, opts ...grpc.CallOption) (*BudgetGetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BudgetGetResponse)
        err := c.cc.Invoke(ctx, LedgerService_BudgetGet_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) BudgetsList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BudgetGetListResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BudgetGetListResponse)
        err := c.cc.Invoke(ctx, LedgerService_BudgetsList_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) TransactionAdd(ctx context.Context, in *TransactionAddRequest, opts ...grpc.CallOption) (*TransactionAddResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TransactionAddResponse)
        err := c.cc.Invoke(ctx, LedgerService_TransactionAdd_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) TransactionGet(ctx context.Context, in *TransactionGetRequest, opts ...grpc.CallOption) (*TransactionGetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TransactionGetResponse)
        err := c.cc.Invoke(ctx, LedgerService_TransactionGet_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) TransactionList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionGetListResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TransactionGetListResponse)
        err := c.cc.Invoke(ctx, LedgerService_TransactionList_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) ReportSummary(ctx context.Context, in *SummaryRequest, opts ...grpc.CallOption) (*SummaryResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SummaryResponse)
        err := c.cc.Invoke(ctx, LedgerService_ReportSummary_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerServiceClient) BulkAddTransactions(ctx context.Context, in *TransactionBulkAddRequest, opts ...grpc.CallOption) (*TransactionBulkAddResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TransactionBulkAddResponse)
        err := c.cc.Invoke(ctx, LedgerService_BulkAddTransactions_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// LedgerServiceServer is the server API for LedgerService service.
// All implementations must embed UnimplementedLedgerServiceServer
// for forward compatibility.
type LedgerServiceServer interface {
        BudgetAdd(context.Context, *BudgetAddRequest) (*emptypb.Empty, error)
        BudgetGet(context.Context, *BudgetGetRequest) (*BudgetGetResponse, error)
        BudgetsList(context.Context, *emptypb.Empty) (*BudgetGetListResponse, error)
        TransactionAdd(context.Context, *TransactionAddRequest) (*TransactionAddResponse, error)
        TransactionGet(context.Context, *TransactionGetRequest) (*TransactionGetResponse, error)
        TransactionList(context.Context, *emptypb.Empty) (*TransactionGetListResponse, error)
        ReportSummary(context.Context, *SummaryRequest) (*SummaryResponse, error)
        BulkAddTransactions(context.Context, *TransactionBulkAddRequest) (*TransactionBulkAddResponse, error)
        mustEmbedUnimplementedLedgerServiceServer()
}

// UnimplementedLedgerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLedgerServiceServer struct{}

func (UnimplementedLedgerServiceServer) BudgetAdd(context.Context, *BudgetAddRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method BudgetAdd not implemented")
}</span>
func (UnimplementedLedgerServiceServer) BudgetGet(context.Context, *BudgetGetRequest) (*BudgetGetResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method BudgetGet not implemented")
}</span>
func (UnimplementedLedgerServiceServer) BudgetsList(context.Context, *emptypb.Empty) (*BudgetGetListResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method BudgetsList not implemented")
}</span>
func (UnimplementedLedgerServiceServer) TransactionAdd(context.Context, *TransactionAddRequest) (*TransactionAddResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method TransactionAdd not implemented")
}</span>
func (UnimplementedLedgerServiceServer) TransactionGet(context.Context, *TransactionGetRequest) (*TransactionGetResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method TransactionGet not implemented")
}</span>
func (UnimplementedLedgerServiceServer) TransactionList(context.Context, *emptypb.Empty) (*TransactionGetListResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method TransactionList not implemented")
}</span>
func (UnimplementedLedgerServiceServer) ReportSummary(context.Context, *SummaryRequest) (*SummaryResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method ReportSummary not implemented")
}</span>
func (UnimplementedLedgerServiceServer) BulkAddTransactions(context.Context, *TransactionBulkAddRequest) (*TransactionBulkAddResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method BulkAddTransactions not implemented")
}</span>
func (UnimplementedLedgerServiceServer) mustEmbedUnimplementedLedgerServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedLedgerServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerServiceServer will
// result in compilation errors.
type UnsafeLedgerServiceServer interface {
        mustEmbedUnimplementedLedgerServiceServer()
}

func RegisterLedgerServiceServer(s grpc.ServiceRegistrar, srv LedgerServiceServer) <span class="cov0" title="0">{
        // If the following call panics, it indicates UnimplementedLedgerServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;LedgerService_ServiceDesc, srv)</span>
}

func _LedgerService_BudgetAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BudgetAddRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetAdd(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_BudgetAdd_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetAdd(ctx, req.(*BudgetAddRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_BudgetGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BudgetGetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetGet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_BudgetGet_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetGet(ctx, req.(*BudgetGetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_BudgetsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetsList(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_BudgetsList_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BudgetsList(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_TransactionAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TransactionAddRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionAdd(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_TransactionAdd_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionAdd(ctx, req.(*TransactionAddRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_TransactionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TransactionGetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionGet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_TransactionGet_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionGet(ctx, req.(*TransactionGetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_TransactionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionList(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_TransactionList_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).TransactionList(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_ReportSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SummaryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).ReportSummary(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_ReportSummary_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).ReportSummary(ctx, req.(*SummaryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LedgerService_BulkAddTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TransactionBulkAddRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BulkAddTransactions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LedgerService_BulkAddTransactions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServiceServer).BulkAddTransactions(ctx, req.(*TransactionBulkAddRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// LedgerService_ServiceDesc is the grpc.ServiceDesc for LedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LedgerService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "ledger.v1.LedgerService",
        HandlerType: (*LedgerServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "BudgetAdd",
                        Handler:    _LedgerService_BudgetAdd_Handler,
                },
                {
                        MethodName: "BudgetGet",
                        Handler:    _LedgerService_BudgetGet_Handler,
                },
                {
                        MethodName: "BudgetsList",
                        Handler:    _LedgerService_BudgetsList_Handler,
                },
                {
                        MethodName: "TransactionAdd",
                        Handler:    _LedgerService_TransactionAdd_Handler,
                },
                {
                        MethodName: "TransactionGet",
                        Handler:    _LedgerService_TransactionGet_Handler,
                },
                {
                        MethodName: "TransactionList",
                        Handler:    _LedgerService_TransactionList_Handler,
                },
                {
                        MethodName: "ReportSummary",
                        Handler:    _LedgerService_ReportSummary_Handler,
                },
                {
                        MethodName: "BulkAddTransactions",
                        Handler:    _LedgerService_BulkAddTransactions_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "ledger/v1/ledger.proto",
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package pg

import (
        "context"
        "database/sql"
        "encoding/json"
        "ledger/internal/domain"
        "time"

        "github.com/redis/go-redis/v9"
)

type BudgetPgRepository struct {
        db    *sql.DB
        cache *redis.Client
}

func NewBudgetPgRepository(db *sql.DB, cache *redis.Client) *BudgetPgRepository <span class="cov8" title="1">{
        return &amp;BudgetPgRepository{
                db:    db,
                cache: cache,
        }
}</span>

func (r *BudgetPgRepository) SetBudget(b *domain.Budget, ctx context.Context) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, "INSERT INTO budgets(category, limit_amount) VALUES($1,$2) ON CONFLICT(category) DO UPDATE SET limit_amount =EXCLUDED.limit_amount", &amp;b.Category, &amp;b.Limit)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">r.cache.Del(ctx, "budgets:all")
        return nil</span>
}

func (r *BudgetPgRepository) GetBudgets(ctx context.Context) ([]domain.Budget, error) <span class="cov8" title="1">{
        key := "budgets:all"
        val, err := r.cache.Get(ctx, key).Result()
        if err == nil </span><span class="cov8" title="1">{
                println("Get budgets from cache")
                var result []domain.Budget
                if err := json.Unmarshal([]byte(val), &amp;result); err == nil </span><span class="cov8" title="1">{
                        return result, nil
                }</span>
        }
        <span class="cov8" title="1">println("Get budgets from db")
        rows, err := r.db.QueryContext(ctx, "SELECT category, limit_amount FROM budgets ORDER BY category")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        println(err.Error())
                }</span>
        }(rows)
        <span class="cov8" title="1">var dbBudgets []domain.Budget
        for rows.Next() </span><span class="cov8" title="1">{
                var b domain.Budget
                if err := rows.Scan(&amp;b.Category, &amp;b.Limit); err != nil </span><span class="cov0" title="0">{
                        return dbBudgets, err
                }</span>
                <span class="cov8" title="1">dbBudgets = append(dbBudgets, b)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return dbBudgets, err
        }</span>
        <span class="cov8" title="1">data, _ := json.Marshal(dbBudgets)
        r.cache.Set(ctx, key, data, 20*time.Second)
        return dbBudgets, nil</span>
}

func (r *BudgetPgRepository) GetBudget(category string, ctx context.Context) (*domain.Budget, error) <span class="cov8" title="1">{
        var budget domain.Budget
        err := r.db.QueryRowContext(ctx, "SELECT category, limit_amount FROM budgets WHERE category = $1", category).Scan(&amp;budget.Category, &amp;budget.Limit)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;budget, err
        }</span>
        <span class="cov8" title="1">return &amp;budget, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package pg

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "ledger/internal/domain"
        "sync"
        "time"

        "github.com/redis/go-redis/v9"
)

type SummaryPgRepository struct {
        db    *sql.DB
        cache *redis.Client
}

func NewSummaryPgRepository(db *sql.DB, cache *redis.Client) *SummaryPgRepository <span class="cov8" title="1">{
        return &amp;SummaryPgRepository{
                db:    db,
                cache: cache,
        }
}</span>

func (r *SummaryPgRepository) GetSummary(ctx context.Context, from string, to string) (*domain.Summary, error) <span class="cov8" title="1">{
        key := "report:summary:" + from + ":" + to
        val, err := r.cache.Get(ctx, key).Result()
        if err == nil </span><span class="cov8" title="1">{
                println("Get result from cache")
                var result map[string]float64
                if err := json.Unmarshal([]byte(val), &amp;result); err == nil </span><span class="cov8" title="1">{
                        return &amp;domain.Summary{Categories: result, CacheResult: true}, nil
                }</span>
        }
        <span class="cov8" title="1">println("Get result from db")
        rows, err := r.db.QueryContext(ctx, "SELECT distinct category FROM expenses WHERE date BETWEEN $1 AND $2", from, to)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        println(err.Error())
                }</span>
        }(rows)
        <span class="cov8" title="1">var categories []string
        for rows.Next() </span><span class="cov0" title="0">{
                var c string
                if err := rows.Scan(&amp;c); err != nil </span><span class="cov0" title="0">{
                        println(err.Error())
                        return nil, err
                }</span>
                <span class="cov0" title="0">categories = append(categories, c)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                println(err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">var wg sync.WaitGroup
        result := make(map[string]float64)
        ticker := time.NewTicker(500 * time.Millisecond)
        defer ticker.Stop()
        done := make(chan bool)

        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-done:<span class="cov8" title="1">
                                fmt.Println("Ticker stopped")
                                return</span>
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                fmt.Println("Tick at", t)</span>
                        }
                }
        }()
        <span class="cov8" title="1">for _, category := range categories </span><span class="cov0" title="0">{
                wg.Go(func() </span><span class="cov0" title="0">{
                        var amount float64
                        r.db.QueryRowContext(ctx, "SELECT sum(amount) FROM expenses WHERE category = $1 AND date BETWEEN $2 AND $3", category, from, to).Scan(&amp;amount)
                        result[category] = amount
                }</span>)
        }
        <span class="cov8" title="1">wg.Wait()
        done &lt;- true
        data, _ := json.Marshal(result)
        print("save result to cache")
        r.cache.Set(ctx, key, data, 30*time.Second)
        return &amp;domain.Summary{Categories: result, CacheResult: false}, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pg

import (
        "context"
        "database/sql"
        "ledger/internal/domain"
        "strconv"
        "strings"
        "time"
)

type TransactionPgRepository struct {
        db *sql.DB
}

func NewTransactionPgRepository(db *sql.DB) *TransactionPgRepository <span class="cov8" title="1">{
        return &amp;TransactionPgRepository{
                db: db,
        }
}</span>

func (r *TransactionPgRepository) GetAmountTransactionByCategory(category string, ctx context.Context) (float64, error) <span class="cov8" title="1">{
        var totalAmount float64
        err := r.db.QueryRowContext(ctx, "SELECT COALESCE(SUM(amount),0) FROM expenses WHERE category=$1", category).Scan(&amp;totalAmount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return totalAmount, nil</span>
}

func (r *TransactionPgRepository) GetAmountTransactionByCategoryAndMonth(ctx context.Context, category string, date string) (float64, error) <span class="cov8" title="1">{
        t, err := time.Parse("2006-01-02", date)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">year := t.Year()
        month := int(t.Month())
        var currentMonthStart strings.Builder
        currentMonthStart.WriteString(strconv.Itoa(year))
        currentMonthStart.WriteString("-")
        currentMonthStart.WriteString(strconv.Itoa(month))
        currentMonthStart.WriteString("-")
        currentMonthStart.WriteString("01")
        var nextMonthStart strings.Builder
        if month == 12 </span><span class="cov8" title="1">{
                nextMonthStart.WriteString(strconv.Itoa(year + 1))
                nextMonthStart.WriteString("-")
                nextMonthStart.WriteString("01")
                nextMonthStart.WriteString("-")
                nextMonthStart.WriteString("01")
        }</span> else<span class="cov0" title="0"> {
                nextMonthStart.WriteString(strconv.Itoa(year))
                nextMonthStart.WriteString("-")
                nextMonthStart.WriteString(strconv.Itoa(month + 1))
                nextMonthStart.WriteString("-")
                nextMonthStart.WriteString("01")
        }</span>

        <span class="cov8" title="1">var totalAmount float64
        err = r.db.QueryRowContext(ctx, "SELECT COALESCE(SUM(amount),0) FROM expenses WHERE category=$1 AND date between $2 and $3", category, currentMonthStart.String(), nextMonthStart.String()).Scan(&amp;totalAmount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return totalAmount, nil</span>
}

func (r *TransactionPgRepository) AddTransaction(transaction *domain.Transaction, ctx context.Context) (int64, error) <span class="cov8" title="1">{
        var newID int64
        err := r.db.QueryRowContext(ctx, "INSERT INTO expenses(amount, category, description, date) VALUES($1,$2,$3,$4) RETURNING id", transaction.Amount, transaction.Category, transaction.Description, transaction.Date).Scan(&amp;newID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return newID, nil</span>
}

func (r *TransactionPgRepository) GetTransaction(id int64, ctx context.Context) (*domain.Transaction, error) <span class="cov8" title="1">{
        var tr domain.Transaction
        err := r.db.QueryRowContext(ctx, "SELECT id, amount, category, description, date FROM expenses where id=$1", id).Scan(&amp;tr.ID, &amp;tr.Amount, &amp;tr.Category, &amp;tr.Description, &amp;tr.Date)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tr, nil</span>
}

func (r *TransactionPgRepository) ListTransactions(ctx context.Context) ([]domain.Transaction, error) <span class="cov8" title="1">{
        rows, err := r.db.QueryContext(ctx, "SELECT id, amount, category, description, date FROM expenses ORDER BY date DESC, id DESC")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        println(err.Error())
                }</span>
        }(rows)
        <span class="cov8" title="1">var dbTransactions []domain.Transaction
        for rows.Next() </span><span class="cov8" title="1">{
                var t domain.Transaction
                if err := rows.Scan(&amp;t.ID, &amp;t.Amount, &amp;t.Category, &amp;t.Description, &amp;t.Date); err != nil </span><span class="cov0" title="0">{
                        return dbTransactions, err
                }</span>
                <span class="cov8" title="1">dbTransactions = append(dbTransactions, t)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return dbTransactions, err
        }</span>
        <span class="cov8" title="1">return dbTransactions, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "ledger/internal/domain"
        "sync"
)

type LedgerService interface {
        BudgetAdd(ctx context.Context, budget *domain.Budget) error
        BudgetGet(ctx context.Context, category string) (*domain.Budget, error)
        BudgetsList(ctx context.Context) (map[string]domain.Budget, error)
        TransactionAdd(ctx context.Context, transaction *domain.Transaction) (int64, error)
        TransactionGet(ctx context.Context, id int64) (*domain.Transaction, error)
        TransactionsList(ctx context.Context) ([]domain.Transaction, error)
        BulkAddTransactions(ctx context.Context, transactions []domain.Transaction, numWorkers int) (*BulkTransactionResult, error)
        GetReportSummary(ctx context.Context, from string, to string) (*domain.Summary, error)
}

type LedgerServiceImpl struct {
        budgetRepository      domain.BudgetRepository
        transactionRepository domain.TransactionRepository
        summaryRepository     domain.SummaryRepository
}

var _ LedgerService = (*LedgerServiceImpl)(nil)

func NewLedgerService(budgetRepository domain.BudgetRepository, transactionsRepository domain.TransactionRepository, summaryRepository domain.SummaryRepository) *LedgerServiceImpl <span class="cov8" title="1">{
        return &amp;LedgerServiceImpl{
                budgetRepository:      budgetRepository,
                transactionRepository: transactionsRepository,
                summaryRepository:     summaryRepository,
        }
}</span>

func (l *LedgerServiceImpl) BudgetAdd(ctx context.Context, budget *domain.Budget) error <span class="cov8" title="1">{
        err := budget.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = l.budgetRepository.SetBudget(budget, ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (l *LedgerServiceImpl) BudgetGet(ctx context.Context, category string) (*domain.Budget, error) <span class="cov8" title="1">{
        budget, err := l.budgetRepository.GetBudget(category, ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return budget, nil</span>
}

func (l *LedgerServiceImpl) BudgetsList(ctx context.Context) (map[string]domain.Budget, error) <span class="cov8" title="1">{
        budgets, err := l.budgetRepository.GetBudgets(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">budgetMap := make(map[string]domain.Budget)
        for _, budget := range budgets </span><span class="cov8" title="1">{
                budgetMap[budget.Category] = budget
        }</span>
        <span class="cov8" title="1">return budgetMap, nil</span>
}

func (l *LedgerServiceImpl) TransactionAdd(ctx context.Context, transaction *domain.Transaction) (int64, error) <span class="cov8" title="1">{
        err := transaction.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("invalid transaction")
        }</span>
        <span class="cov8" title="1">budget, err := l.budgetRepository.GetBudget(transaction.Category, ctx)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">amount, err := l.transactionRepository.GetAmountTransactionByCategoryAndMonth(ctx, transaction.Category, transaction.Date)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if amount+transaction.Amount &gt; budget.Limit </span><span class="cov8" title="1">{
                return 0, errors.New("budget exceeded")
        }</span>
        <span class="cov8" title="1">id, err := l.transactionRepository.AddTransaction(transaction, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (l *LedgerServiceImpl) TransactionGet(ctx context.Context, id int64) (*domain.Transaction, error) <span class="cov8" title="1">{
        transaction, err := l.transactionRepository.GetTransaction(id, ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return transaction, err</span>
}

func (l *LedgerServiceImpl) TransactionsList(ctx context.Context) ([]domain.Transaction, error) <span class="cov8" title="1">{
        transactions, err := l.transactionRepository.ListTransactions(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return transactions, nil</span>
}

func (l *LedgerServiceImpl) GetReportSummary(ctx context.Context, from string, to string) (*domain.Summary, error) <span class="cov8" title="1">{
        return l.summaryRepository.GetSummary(ctx, from, to)
}</span>

type Result struct {
        success  bool
        errorStr string
        index    int64
}

func (r *LedgerServiceImpl) worker(id int, jobs &lt;-chan WorkerJob, results chan&lt;- Result, ctx context.Context, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        for </span><span class="cov0" title="0">{
                select </span>{
                case job, ok := &lt;-jobs:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                fmt.Printf("Worker %d exiting because jobs channel closed\n", id)
                                return
                        }</span>
                        <span class="cov0" title="0">transaction := job.transaction
                        err := transaction.Validate()
                        if err != nil </span><span class="cov0" title="0">{
                                results &lt;- Result{success: false, errorStr: "invalid transaction", index: job.index}
                                break</span>
                        }
                        <span class="cov0" title="0">budget, err := r.budgetRepository.GetBudget(transaction.Category, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "sql: no rows in result set" </span><span class="cov0" title="0">{
                                        results &lt;- Result{success: false, errorStr: "no budget category", index: job.index}
                                        break</span>
                                }
                                <span class="cov0" title="0">results &lt;- Result{success: false, errorStr: err.Error(), index: job.index}
                                break</span>
                        }
                        <span class="cov0" title="0">amount, err := r.transactionRepository.GetAmountTransactionByCategory(transaction.Category, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                results &lt;- Result{success: false, errorStr: err.Error(), index: job.index}
                                break</span>
                        }
                        <span class="cov0" title="0">if amount+transaction.Amount &gt; budget.Limit </span><span class="cov0" title="0">{
                                results &lt;- Result{success: false, errorStr: "budget exceeded", index: job.index}
                                break</span>
                        }
                        <span class="cov0" title="0">_, err = r.transactionRepository.AddTransaction(&amp;transaction, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                results &lt;- Result{success: false, errorStr: err.Error(), index: job.index}
                                break</span>
                        }
                        <span class="cov0" title="0">results &lt;- Result{success: true, errorStr: "", index: job.index}</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        fmt.Printf("Worker %d exiting due to context cancellation\n", id)
                        return</span>
                }
        }
}

type BulkTransactionResult struct {
        Accepted int64
        Rejected int64
        Errors   map[int64]string
        m        sync.Mutex
}

type WorkerJob struct {
        index       int64
        transaction domain.Transaction
}

func (r *LedgerServiceImpl) BulkAddTransactions(ctx context.Context, transactions []domain.Transaction, numWorkers int) (*BulkTransactionResult, error) <span class="cov0" title="0">{
        jobs := make(chan WorkerJob, len(transactions))
        results := make(chan Result, len(transactions))
        var wg sync.WaitGroup
        for w := range numWorkers </span><span class="cov0" title="0">{
                wg.Add(1)
                go r.worker(w, jobs, results, ctx, &amp;wg)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(transactions); j++ </span><span class="cov0" title="0">{
                        jobs &lt;- WorkerJob{index: int64(j), transaction: transactions[j]}
                }</span>
                <span class="cov0" title="0">close(jobs)</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()
        <span class="cov0" title="0">res := BulkTransactionResult{Accepted: 0, Rejected: 0}
        res.Errors = make(map[int64]string)

        for result := range results </span><span class="cov0" title="0">{
                res.m.Lock()
                if result.success </span><span class="cov0" title="0">{
                        res.Accepted++
                }</span> else<span class="cov0" title="0"> {
                        res.Rejected++
                        res.Errors[result.index] = result.errorStr
                }</span>
                <span class="cov0" title="0">res.m.Unlock()</span>
        }

        <span class="cov0" title="0">return &amp;res, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
